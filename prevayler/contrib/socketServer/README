                   prevayler.socketServer
      Contributed by David Orme <daveo@swtworkbench.com>
                           README


What is prevayler.socketServer?
-------------------------------

prevayler.socketServer is a client/server framework for 
creating prevalent system servers.  It aims to be thin
and fast, yet full-featured, including:

- Treating Prevayler transactions as simple remote method 
  invocations.
- Providing transparent exception handling, propogation,
  and (optionally) logging.
- Implementing a client-server Observer framework so that 
  clients can be notified when "interesting" changes occur 
  in the server-side business objects.  This last feature 
  goes way beyond the features of most relational 
  databases.


Organization of Distribution Subdirectories
-------------------------------------------

server             - Root of server application classpath
client             - Root of client library classpath
common             - Root of transactions and utilities classpath

example            - Example application using the socket server
                     See the README file inside this directory 
                     for more information.


Philosophy
----------

prevayler.socketServer regards Prevayler as another way to 
implement remote procedure calls, with the added benefit of 
transparent object prevalence.  From the client's perspective, 
each Prevayler Transaction is like a function object that is
executed on a remote object and either returns a result or
throws an exception.  Since Prevayler Transaction objects
can accept arbitrary parameters and throw arbitrary exceptions,
so can prevayler.socketServer.  Lastly, everything is designed
to be as automatic as possible so that the client objects 
do not need to know if the server threads/objects are running
in the same VM, in a different VM on the same computer, or 
on another computer halfway around the world.

In addition to the remote procedure call framework, 
prevayler.socketServer implements an Observer pattern whereby
client objects can request notification of events occuring
inside server objects.  The library automatically optimizes
network traffic to send only the events that are actually 
being requested by actual clients.


Library Constraints
-------------------

In addition to the constraints imposed by using Prevayler itself, 
there is exactly one additional constraint required in order to 
use the prevayler.socketServer library:

- All Transactions must implement IRemoteTransaction

This may either be done manually or automatically.  A class,
RemoteTransaction, has been provided that implements
IRemoteTransaction.  Creating your own Transactions by extending
RemoteTransaction will automatically ensure that your Transactions
fulfill this requirement.

(IRemoteTransaction makes all Transactions aware of the client from
which they originated.  Any events generated by the observer
framework are automatically tagged with the connection ID of the
client that triggered them.  Using this mechanism, clients
receiving notifications can automatically determine if they
were the client that triggered the notification and avoid
circumstances that could lead to infinite loops of Transactions
generating callbacks generating Transactions generating 
callbacks generating...)


Getting Started--Server
-----------------------

The socketServer library does not require any code modifications
in order to use.  Simply place your PrevalentSystem object somewhere
on the classpath of the socketServer application.  Then include your
PrevalentSystem's class name in the Config.ini file for the server.
The server will automatically find and load your PrevalentSystem
at startup.  See the example application for more on options 
provided in Config.ini.

The main() class for the socket server is
org.prevayler.socketserver.server.Main.

The root of the callback notification framework on the server is
the static methods on the Notification object.


Getting Started--Client
-----------------------

The Remote object manages a connection to a remote server.  Its
constructor initializes a public static member "conn" to the last-
constructed instance (the Singleton pattern) in order to easily
support the common case where there is exactly one connection
to exactly one server in an application.

Once the Remote singleton is constructed, Transactions (remote
method calls) may be executed on the server using:

try {
   myRemoteObject.exec(new MyTransaction(arg1, arg2, ...));
} catch (....) {
}

or in the Singleton case:

try {
   Remote.conn.exec(new MyTransaction(arg1, arg2, ...));
} catch (....) {
}

Other convenience methods are provided that automatically handle 
the case where an exception is never expected so only logging
should occur in the unforseen event that an exception is thrown.

Once a connection is established, Observer pattern callbacks 
may be requested using the registerCallback() and 
unregisterCallback() methods of the Remote object.  Callback
event objects must implement the IModelCallback interface.

When the client is finished, it should call the close() method
on its Remote object in order to gracefully tear down all socket 
connections and release all other resources used by the connection.


Logging framework
-----------------

A simple logging framework is provided inside the 
org.prevayler.socketserver.util package in the "common"
subdirectory.  Since the prevayler.socketServer library has
extremely simple logging requirements, it provides its own
logging library that is ridiculously easy to hook up to 
the logging framework of your choice (log4j, etc).


Generic configuration
---------------------

A simple configuration framework is provided by the abstract
org.prevayler.socketserver.util.Config class.  An example of how
to use this class is provided in 
org.prevayler.socketserver.server.ServerConfig.


What if the server crashes?
---------------------------

If the server crashes or is shut down while clients are still
up, all subsequent calls to Remote.conn.exec() will throw
a java.net.SocketException.  Calls to Remote.conn.execl() will
log this exception, then return null.

Client code should be prepared to deal with this eventuality
in whatever means makes sense: shut down, wait for a specified
amount of time then try to reconnect, etc.

